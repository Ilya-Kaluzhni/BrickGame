#include "tetris.h" // подключает заголовочный файл с объявлением класса Tetris и зависимостями

// макрос, определяющий массив координат шаблона фигуры Teewee
#define TEEWEE { 1, 4, 1, 3, 0, 4, 1, 5 } // значения Y,X пар для четырёх блоков фигуры Teewee
// макрос, определяющий массив координат шаблона фигуры Hero
#define HERO { 0, 5, 0, 4, 0, 3, 0, 6 } // значения Y,X пар для четырёх блоков фигуры Hero
#define SMASHBOY { 0, 4, 0, 5, 1, 4, 1, 5 } // значения Y,X пар для четырёх блоков фигуры Smashboy
#define ORANGE_RICKY { 1, 4, 1, 3, 1, 5, 0, 5 } // значения Y,X пар для четырёх блоков фигуры Orange Ricky
#define BLUE_RICKY { 1, 4, 0, 3, 1, 3, 1, 5 } // значения Y,X пар для четырёх блоков фигуры Blue Ricky
#define CLEVELAND_Z { 1, 4, 0, 3, 0, 4, 1, 5 } // значения Y,X пар для четырёх блоков фигуры Cleveland Z
#define RHODE_ISLAND_Z { 1, 4, 1, 3, 0, 4, 0, 5 } // значения Y,X пар для четырёх блоков фигуры Rhode Island Z

#define DATA_FILE_NAME "tetris_data.bin" // имя бинарного файла для сохранения рекорда

#define SUCCSES 0 // код успешного выполнения операции
#define ERROR 1 // код ошибки выполнения операции

#define TIMER_MAX_DELAY 1000 // максимальная задержка таймера в миллисекундах
#define TIMER_MIN_DELAY 200 // минимальная задержка таймера в миллисекундах
#define TIMER_MAX_SPEED 10 // максимальное значение скорости для таймера

#define Y_CORDS 0 // индекс в массиве фигур, соответствующий координате Y
#define X_CORDS 1 // индекс в массиве фигур, соответствующий координате X
#define LEFT -1 // смещение влево (отрицательное по X)
#define RIGHT 1 // смещение вправо (положительное по X)
#define UP -1 // смещение вверх (отрицательное по Y)
#define DOWN 1 // смещение вниз (положительное по Y)

#define BRICK_RANDOMIZER (1 + rand() % 7) // выражение для генерации случайного номера фигуры от 1 до 7
#define COLOR_RANDOMIZER (1 + rand() % 6) // выражение для генерации случайного цвета от 1 до 6

namespace s21 { // начало пространства имён s21


/**
 * @brief GameStart (состояние конечного автомата).
 *
 * Инициализация начала игры.
 */
void Tetris::starting_game() { // определение метода начальной логики состояния Start
  if (action == Start) { // если пришло действие старта игры
    stats_init(this); // инициализируем статистику и выделяем память для фигур
    init_score(this); // инициализируем счёт и читаем рекорд из файла
    new_brick(next_brick, BRICK_RANDOMIZER); // генерируем случайную следующую фигуру
    gameinfo.level = 1; // устанавливаем начальный уровень в 1
    statemachine = Spawn; // переводим конечный автомат в состояние Spawn
  } else if (action == Terminate) { // если пришло действие завершения игры
    statemachine = GameOver; // переводим конечный автомат в состояние GameOver
  } // конец условия обработки действий в starting_game
} // конец реализации starting_game

/**
 * @brief Генерирует новую случайную фигуру для спауна.
 *
 * @param random номер фигуры от 1 до 7
 */
void Tetris::new_brick(int* brick, int random) { // реализация генерации шаблона фигуры по номеру
  Bricks bricks = {TEEWEE,     HERO,        SMASHBOY,      ORANGE_RICKY,
                   BLUE_RICKY, CLEVELAND_Z, RHODE_ISLAND_Z}; // создаём локальную структуру со всеми шаблонами фигур
  switch (random) { // выбираем шаблон по значению random
    case 1: // если random == 1
      brick_copy(brick, bricks.Teewee); // копируем шаблон Teewee в массив brick
      break; // прерываем case 1
    case 2: // если random == 2
      brick_copy(brick, bricks.Hero); // копируем шаблон Hero
      break; // прерываем case 2
    case 3: // если random == 3
      brick_copy(brick, bricks.Smashboy); // копируем шаблон Smashboy
      break; // прерываем case 3
    case 4: // если random == 4
      brick_copy(brick, bricks.Orange_Ricky); // копируем шаблон Orange Ricky
      break; // прерываем case 4
    case 5: // если random == 5
      brick_copy(brick, bricks.Blue_Ricky); // копируем шаблон Blue Ricky
      break; // прерываем case 5
    case 6: // если random == 6
      brick_copy(brick, bricks.Cleveland_Z); // копируем шаблон Cleveland Z
      break; // прерываем case 6
    case 7: // если random == 7
      brick_copy(brick, bricks.Rhode_Island_Z); // копируем шаблон Rhode Island Z
      break; // прерываем case 7
    default: // на случай некорректного номера
      break; // ничего не делаем в блоке по умолчанию
  } // конец switch
} // конец функции new_brick

/**
 * @brief Spawn (состояние конечного автомата).
 *
 * Обновляет текущий и следующий цвет фигуры, размещает следующую фигуру
 * на поле, копирует её в текущую, генерирует новую случайную фигуру для спауна
 * и обновляет поле следующей фигуры. Переводит конечный автомат в состояние Moving.
 */
void Tetris::spawn() { // реализация состояния Spawn конечного автомата
  current_color = next_color; // присваиваем текущему цвету значение следующего цвета
  next_color = COLOR_RANDOMIZER; // генерируем новый случайный цвет для следующей фигуры
  spawn_brick(gameinfo.field, next_brick, current_color); // отображаем next_brick на основном поле с цветом current_color
  brick_copy(current_brick, next_brick); // копируем next_brick в current_brick (теперь текущая фигура — следующая)
  new_brick(next_brick, BRICK_RANDOMIZER); // генерируем новый шаблон для next_brick
  fill_array_zero(gameinfo.next, NEXT_SIZE, NEXT_SIZE); // очищаем матрицу для отображения следующей фигуры
  spawn_brick(gameinfo.next, next_brick, next_color); // отображаем next_brick в окне "следующая фигура" с цветом next_color
  statemachine = Moving; // переводим конечный автомат в состояние Moving
} // конец метода spawn

/**
 * @brief Moving (состояние конечного автомата).
 * 
 * Основной игровой цикл перемещения фигуры.
 * Обрабатывает действия игрока (Pause, Terminate, Down),
 * перемещает фигуру, проверяет таймер и переводит КА в состояние Shifting при необходимости.
 */
void Tetris::moving() { // реализация состояния Moving
  if (action == Pause && gameinfo.pause == 0) { // если пришло действие паузы и игра не на паузе
    gameinfo.pause = 1; // ставим игру на паузу
    action = Start; // сбрасываем действие в Start для предотвращения повторной обработки
  } else if (action == Pause && gameinfo.pause == 1) { // если пришло действие паузы и игра уже на паузе
    gameinfo.pause = 0; // снимаем паузу
    action = Start; // сбрасываем действие в Start
  } else if (action == Terminate) { // если пришло действие завершения игры
    statemachine = GameOver; // переводим КА в состояние GameOver
  } // конец обработки действий Pause/Terminate
  if (gameinfo.pause != 1) { // если игра не на паузе (активна)
    despawn(gameinfo.field, current_brick); // удаляем текущее отображение фигуры с поля перед перемещением
    brick_move(current_brick, action, gameinfo.field); // обрабатываем пользовательские действия и перемещаем фигуру
    spawn_brick(gameinfo.field, current_brick, current_color); // повторно отображаем фигуру на поле после перемещения
    if (time.game_timer_check(gameinfo.speed, TIMER_MAX_DELAY, TIMER_MIN_DELAY,
                              TIMER_MAX_SPEED) || // если таймер сработал с учётом скорости и лимитов
        action == Down) { // либо если пользователь запросил ускоренное падение вниз
      time.start(); // перезапускаем таймер после срабатывания
      statemachine = Shifting; // переводим КА в состояние Shifting для смещения фигуры вниз
    } else {
      action = Start; // сбрасываем действие в Start чтобы избежать повторного применения
    } // конец условия проверки таймера / действия Down
  } // конец проверки паузы
} // конец метода moving

/**
 * @brief Shifting (состояние конечного автомата).
 * 
 * Сдвигает фигуру вниз, если это возможно.
 * Если фигура может двигаться вниз, координаты Y сдвигаются,
 * иначе КА переходит в состояние Attaching. После сдвига фигура "спавнится" обратно на поле.
 */
void Tetris::shifting() { // реализация состояния Shifting
  despawn(gameinfo.field, current_brick); // удаляем текущее отображение фигуры перед сдвигом
  if (check_down(gameinfo.field, current_brick)) { // если можно опустить фигуру вниз
    coord_shift(current_brick, Y_CORDS, DOWN); // сдвигаем координаты Y всех блоков фигуры вниз на единицу
    statemachine = Moving; // возвращаемся в состояние Moving для дальнейшей обработки
  } else { // если нельзя опустить вниз (столкновение или дно)
    statemachine = Attaching; // переводим КА в состояние Attaching для прикрепления фигуры к полю
  } // конец проверки возможности опускания
  spawn_brick(gameinfo.field, current_brick, current_color); // отображаем фигуру снова на поле после сдвига/решения о прикреплении
} // конец метода shifting

/**
 * @brief Attaching (состояние конечного автомата).
 * 
 * Прикрепляет фигуру к полю и проверяет заполненные строки.
 * Считает полные строки и обновляет счёт,
 * проверяет условия окончания игры и переводит КА в следующее состояние.
 */
void Tetris::attaching() { // реализация состояния Attaching
  int full_rows_counter = 0; // счётчик полностью заполненных строк
  full_rows_counter = check_full_row(gameinfo.field); // проверяем и получаем количество заполненных строк
  if (action == Down) { // если пользователь нажал Down ранее
    action = Start; // сбрасываем действие в Start
  } // конец обработки действия Down
  if (check_gameover(current_brick)) { // проверяем условие поражения/конца игры
    statemachine = GameOver; // переводим КА в состояние GameOver при окончании игры
  } else if (full_rows_counter) { // если были полные строки
    score_write(this, full_rows_counter); // обновляем счёт в зависимости от количества удалённых строк
    check_level(this); // проверяем и обновляем уровень при необходимости
  } else { // если полных строк нет и игра не окончена
    statemachine = Spawn; // переходим к появлению новой фигуры
  } // конец логики обработки прикрепления
} // конец метода attaching

/**
 * @brief Game_over (состояние конечного автомата).
 *
 * Освобождает память под текущую и следующую фигуры и устанавливает уровень в -1.
 */
void Tetris::game_over() { // реализация состояния GameOver
  if (gameinfo.level > 0) { // если уровень положителен (игра началась и память была выделена)
    free(current_brick); // освобождаем память, выделенную под текущую фигуру
    free(next_brick); // освобождаем память, выделенную под следующую фигуру
  } // конец проверки уровня перед освобождением памяти
  gameinfo.level = -1; // ставим уровень -1 как индикатор выхода/завершения игры
} // конец метода game_over

/**
 * @brief Инициализирует динамическую матрицу.
 *
 * @param matrix указатель на матрицу
 * @param height высота матрицы
 * @param width ширина матрицы
 * @return указатель на выделенную матрицу или NULL при некорректных размерах
 */
int** Tetris::init_matrix(int** matrix, int height, int width) { // выделение динамической матрицы height x width
  if (height <= 0 || width <= 0) { // проверяем корректность размеров
    matrix = NULL; // если размеры некорректны, возвращаем NULL
  } else {
    matrix = (int**)malloc(height * sizeof(int*)); // выделяем массив указателей на строки матрицы
    for (int i = 0; i < height; i++) { // для каждой строки
      matrix[i] = (int*)malloc(width * sizeof(int)); // выделяем память под столбцы в строке
    } // конец цикла выделения строк матрицы
    fill_array_zero(matrix, height, width); // заполняем матрицу нулями для инициализации
  } // конец условия выделения матрицы
  return matrix; // возвращаем указатель на выделенную и инициализированную матрицу или NULL
} // конец метода init_matrix

/**
 * @brief Освобождает память выделенной матрицы.
 *
 * @param matrix указатель на матрицу
 * @param size количество строк в матрице
 */
void Tetris::free_memory_matrix(int** matrix, int size) { // освобождение памяти матрицы с заданным количеством строк
  if (size <= 0) { // если размер некорректен
    matrix = NULL; // ничего не делаем, присваиваем NULL локальной переменной
  } else {
    for (int i = 0; i < size; i++) { // проходим по всем строкам
      free(matrix[i]); // освобождаем память каждой строки
    } // конец цикла освобождения строк
    free(matrix); // освобождаем массив указателей на строки
  } // конец условия освобождения памяти
} // конец метода free_memory_matrix

/**
 * @brief Заполняет матрицу нулями.
 *
 * @param matrix указатель на матрицу
 * @param height высота матрицы
 * @param width ширина матрицы
 */
void Tetris::fill_array_zero(int** matrix, int height, int width) { // установка всех ячеек матрицы в 0
  for (int i = 0; i < height; i++) { // цикл по строкам
    for (int j = 0; j < width; j++) { // цикл по столбцам
      matrix[i][j] = 0; // присваиваем ячейке значение 0
    } // конец цикла по столбцам
  } // конец цикла по строкам
} // конец метода fill_array_zero

/**
 * @brief Проверяет возможность сдвига фигуры вправо.
 *
 * @param matrix игровое поле
 * @param brick массив координат фигуры
 * @param shift величина сдвига
 * @return 1 если можно двигаться, иначе 0
 */
int Tetris::check_right(int** matrix, int* brick, int shift) { // проверка возможности движения вправо с учётом границ и занятых ячеек
  int res = 1; // флаг доступности движения вправо, по умолчанию доступно
  for (int i = 1; i < BRICK_SIZE; i += 2) { // проходим по индексам X в массиве координат (каждая вторая позиция)
    if ((brick[i] + shift > WINDOW_WIDTH - 1) || // если после сдвига координата выйдет за правую границу
        (matrix[brick[i - 1]][brick[i] + shift])) { // либо целевая ячейка уже занята на поле
      res = 0; // движение вправо недоступно
    } // конец условия проверки для текущего блока фигуры
  } // конец цикла по блокам фигуры
  return res; // возвращаем результат проверки
} // конец метода check_right

/**
 * @brief Проверяет возможность сдвига фигуры влево.
 *
 * @param matrix игровое поле
 * @param brick массив координат фигуры
 * @param shift величина сдвига
 * @return 1 если можно двигаться, иначе 0
 */
int Tetris::check_left(int** matrix, int* brick, int shift) { // проверка возможности движения влево
  int res = 1; // по умолчанию движение доступно
  for (int i = 1; i < BRICK_SIZE; i += 2) { // проходим по индексам X в массиве координат
    if ((brick[i] - shift < 0) || (matrix[brick[i - 1]][brick[i] - shift])) { // если после сдвига выйдем за левую границу либо ячейка занята
      res = 0; // движение влево недоступно
    } // конец условия проверки для текущего блока
  } // конец цикла по блокам
  return res; // возвращаем флаг доступности движения влево
} // конец метода check_left

/**
 * @brief Проверяет возможность опускания фигуры вниз.
 *
 * @param matrix игровое поле
 * @param brick массив координат фигуры
 * @return 1 если можно опускать, иначе 0
 */
int Tetris::check_down(int** matrix, int* brick) { // проверка возможности опускания фигуры на одну строку вниз
  int res = 1; // по умолчанию опускание доступно
  for (int i = 0; i < BRICK_SIZE; i += 2) { // проходим по индексам Y в массиве координат (каждая вторая позиция начиная с 0)
    if ((brick[i] + 1 >= WINDOW_HEIGHT) || matrix[brick[i] + 1][brick[i + 1]]) { // если после опускания выйдем за нижнюю границу либо ячейка занята
      res = 0; // опускание недоступно
    } // конец условия проверки для текущего блока
  } // конец цикла по блокам фигуры
  return res; // возвращаем результат проверки опускания
} // конец метода check_down

/**
 * @brief Размещает фигуру на игровом поле.
 *
 * @param matrix игровое поле
 * @param array массив координат фигуры
 * @param color цвет фигуры
 */
void Tetris::spawn_brick(int** matrix, int* array, int color) { // отображение фигуры на поле, присвоение ячейкам значения цвета
  for (int i = 0; i < BRICK_SIZE; i += 2) { // проходим по парам Y,X в массиве координат
    matrix[array[i]][array[i + 1]] = color; // устанавливаем в поле значение color для соответствующей позиции
  } // конец цикла по блокам фигуры
} // конец метода spawn_brick

/**
 * @brief Инициализирует структуру Tetris перед началом игры.
 *
 * Выделяет память под текущую и следующую фигуры,
 * обнуляет статистику, устанавливает случайные цвета.
 */
void Tetris::stats_init(Tetris* tetris) { // инициализация полей структуры Tetris и выделение памяти для фигур
  tetris->current_brick = (int*)malloc(sizeof(int) * BRICK_SIZE); // выделяем память под массив текущей фигуры
  tetris->next_brick = (int*)malloc(sizeof(int) * BRICK_SIZE); // выделяем память под массив следующей фигуры
  tetris->gameinfo.level = 0; // обнуляем уровень
  tetris->gameinfo.pause = 0; // снимаем паузу
  tetris->gameinfo.speed = 0; // обнуляем скорость
  tetris->gameinfo.score = 0; // обнуляем счёт
  tetris->gameinfo.high_score = 0; // обнуляем локальное значение рекорда (будет перезаписано при чтении)
  tetris->current_color = COLOR_RANDOMIZER; // задаём случайный текущий цвет
  tetris->next_color = COLOR_RANDOMIZER; // задаём случайный следующий цвет
} // конец метода stats_init

/**
 * @brief Инициализирует рекорд игрока.
 *
 * Открывает существующий бинарный файл с рекордом или создаёт новый.
 *
 * @return 0 при успешной инициализации, 1 при ошибке открытия/создания файла
 */
int Tetris::init_score(Tetris* tetris) { // чтение/создание файла рекорда и установка значения high_score
  int record = 0; // временная переменная для хранения рекорда
  int res = 0; // переменная результата: 0 — успех, 1 — ошибка
  FILE* file; // указатель на файл
  const char* filename = DATA_FILE_NAME; // имя файла с рекордом
  file = fopen(filename, "rb"); // пытаемся открыть файл для чтения в бинарном режиме
  if (file == NULL) { // если файл не существует или не открылся
    file = fopen(filename, "wb"); // пробуем создать файл для записи в бинарном режиме
    if (file != NULL) { // если создание прошло успешно
      fwrite(&record, sizeof(int), 1, file); // записываем начальное значение рекорда (0) в файл
      fclose(file); // закрываем созданный файл
    } else { // если не удалось создать файл
      res = 1; // устанавливаем код ошибки
    } // конец проверки создания файла
  } else { // если файл успешно открыт для чтения
    fread(&record, sizeof(int), 1, file); // читаем значение рекорда из файла
    tetris->gameinfo.high_score = record; // записываем прочитанное значение в структуру Tetris
    fclose(file); // закрываем файл после чтения
  } // конец блока обработки файла рекорда
  return res; // возвращаем результат инициализации (0 — успех, 1 — ошибка)
} // конец метода init_score

/**
 * @brief Проверяет заполненные строки на игровом поле.
 *
 * Удаляет полностью заполненные строки и сдвигает оставшиеся вниз.
 * @return количество заполненных строк
 */
int Tetris::check_full_row(int** field) { // начало метода проверки и удаления полностью заполненных строк
  int res = 0; // инициализация счётчика удалённых строк
  for (int i = WINDOW_HEIGHT - 1; i > 1; i--) { // проход снизу вверх по строкам поля, пропуская верхние служебные строки
    bool flag = true; // флаг, предполагающий что строка заполнена полностью
    for (int j = 0; (j < WINDOW_WIDTH) && flag; j++) { // проверка каждой ячейки строки до выявления пустой
      if (field[i][j] == 0) { // если найдена пустая ячейка
        flag = false; // помечаем строку как незаполненную
      } // конец проверки ячейки
    } // конец цикла по столбцам
    if (flag) { // если строка полностью заполнена
      res++; // увеличиваем счётчик удалённых строк
      for (int k = i; k > 1; k--) { // сдвигаем все строки выше вниз на одну позицию, начиная с текущей строки
        for (int m = 0; m < WINDOW_WIDTH; m++) { // проход по всем столбцам для копирования значений
          field[k][m] = field[k - 1][m]; // переносим значение из строки выше в текущую
        } // конец цикла по столбцам при сдвиге
      } // конец цикла сдвига строк вниз
      i++; // увеличиваем индекс, чтобы повторно проверить строку, которая сместилась на текущую позицию
    } // конец обработки заполненной строки
  } // конец цикла по строкам поля
  return res; // возвращаем количество удалённых строк
} // конец метода check_full_row

/**
 * @brief Убирает фигуру с игрового поля.
 *
 * @param matrix игровое поле
 * @param array массив координат фигуры
 */
void Tetris::despawn(int** matrix, int* array) { // начало метода удаления фигуры с поля (обнуление её ячеек)
  for (int i = 0; i < BRICK_SIZE; i += 2) { // проход по парам Y,X в массиве координат фигуры
    matrix[array[i]][array[i + 1]] = 0; // устанавливаем соответствующую ячейку поля в 0 (удаляем блок)
  } // конец цикла по блокам фигуры
} // конец метода despawn


/**
 * @brief Проверяет, является ли фигура квадратом.
 *
 * @return 1 если фигура квадрат, иначе 0
 */

int Tetris::is_Smashboy(int* brick) { // начало метода определения квадрата (Smashboy)
  int res = 0; // по умолчанию считаем, что фигура не квадрат
  if (brick[4] == brick[0] + 1 && brick[6] == brick[2] + 1 && // проверяем расположение Y для правой колонки относительно левой
      brick[3] == brick[1] + 1 && brick[7] == brick[5] + 1 && // проверяем расположение X для нижней строки относительно верхней
      brick[1] == brick[5] && brick[3] == brick[7]) // проверяем выравнивание по X и Y для колонок/строк (равные координаты)
    res = 1; // если все условия выполнены, помечаем как квадрат
  return res; // возвращаем результат проверки
} // конец метода is_Smashboy

/**
 * @brief Проверяет, является ли фигура типом "Hero".
 *
 * @return 1 если фигура Hero, иначе 0
 */
int Tetris::is_Hero(int* brick) { // начало метода проверки линейной фигуры (Hero)
  int res = 0; // по умолчанию не является Hero
  if ((brick[0] == brick[2] && brick[2] == brick[4] && brick[4] == brick[6]) || // проверка одинаковых Y для всех блоков (вертикальная линия)
      (brick[1] == brick[3] && brick[3] == brick[5] && brick[5] == brick[7])) { // проверка одинаковых X для всех блоков (горизонтальная линия)
    res = 1; // если одно из условий выполнено — это Hero
  } // конец условия проверки Hero
  return res; // возвращаем результат проверки
} // конец метода is_Hero

/**
 * @brief Сдвигает координаты фигуры по X или Y.
 *
 * @param cords 0 для Y координат, 1 для X координат
 * @param shift величина сдвига
 */
void Tetris::coord_shift(int* brick, int cords, int shift) { // начало метода сдвига координат выбранного типа (Y или X)
  for (int i = cords; i < BRICK_SIZE; i += 2) { // проход по соответствующим индексам (0,2,4,6 для Y или 1,3,5,7 для X)
    brick[i] += shift; // изменяем координату на указанное значение shift
  } // конец цикла сдвига координат
} // конец метода coord_shift

/**
 * @brief Проверяет, можно ли опустить фигуру вниз.
 *
 * @return 1 если возможно, иначе 0
 */
int Tetris::check_attaching(int* brick, int** matrix) { // начало метода проверки прикрепления/опускания
  int res = 0; // по умолчанию считаем, что прикрепление требуется
  if (check_down(matrix, brick)) { // если можно опустить вниз (нет препятствий)
    coord_shift(brick, Y_CORDS, DOWN); // сдвигаем координаты Y фигуры вниз на 1
  } else {
    res = 1; // иначе помечаем, что фигура должна прикрепиться (возвращаем 1)
  } // конец проверки возможности опускания
  return res; // возвращаем результат: 0 — сдвинуто, 1 — надо прикрепить
} // конец метода check_attaching

/**
 * @brief Поворачивает фигуру на игровом поле.
 *
 * Создаёт временную матрицу и вычисляет новые координаты фигуры
 * с учётом типа фигуры и её положения.
 */
void Tetris::rotate(int** matrix, int* brick, int size) { // начало метода поворота фигуры с учётом размера шаблона size
  int** temp = NULL; // указатель на временную матрицу для текущего положения фигуры
  int** rotate = NULL; // указатель на матрицу для результата поворота
  temp = init_matrix(temp, size, size); // выделяем временную матрицу размером size x size
  rotate = init_matrix(rotate, size, size); // выделяем матрицу для результата поворота
  int* temp_brick = (int*)malloc(sizeof(int) * BRICK_SIZE); // выделяем память для временного хранения координат фигуры
  brick_copy(temp_brick, brick); // копируем текущие координаты в temp_brick на случай отката поворота
  int centre_cord = (size == 3) ? 1 : 2; // вычисляем центральную координату внутри матрицы (для центровки поворота)
  int min_Y = brick[0] - centre_cord; // определяем верхний Y угол для размещения фигуры в temp
  int min_X = brick[1] - centre_cord; // определяем левый X угол для размещения фигуры в temp
  for (int i = 0; i < BRICK_SIZE; i += 2) { // проходим по всем блокам фигуры
    temp[brick[i] - min_Y][brick[i + 1] - min_X] = 1; // помечаем соответствующую ячейку в temp как занятую
  } // конец заполнения temp матрицы текущей фигурой
  for (int i = 0; i < size; i++) { // цикл по строкам матрицы размера size
    for (int j = 0; j < size; j++) { // цикл по столбцам матрицы размера size
      rotate[j][i] = temp[size - i - 1][j]; // выполняем поворот матрицы temp и записываем в rotate (трансформация координат)
    } // конец внутреннего цикла по столбцам
  } // конец цикла поворота матрицы
  int k = 2; // индекс для записи блоков в массив brick, начиная с третьего элемента (первые два — опорные)
  brick[0] = centre_cord + min_Y; // устанавливаем новую опорную Y координату (центр) в brick[0]
  brick[1] = centre_cord + min_X; // устанавливаем новую опорную X координату (центр) в brick[1]
  for (int i = 0; i < size; i++) { // проходим результирующую матрицу rotate по строкам
    for (int j = 0; j < size; j++) { // проходим по столбцам результирующей матрицы
      if (rotate[i][j] && (i != centre_cord || j != centre_cord)) { // если в результирующей матрице есть блок и это не центр
        brick[k] = i + min_Y; // записываем Y координату блока обратно в массив brick
        brick[k + 1] = j + min_X; // записываем X координату блока обратно в массив brick
        k += 2; // сдвигаем индекс для следующего блока
      } // конец проверки наличия блока и исключения центра
    } // конец внутреннего цикла по столбцам
  } // конец цикла по результирующей матрице
  fix_brick_coord(brick); // корректируем координаты фигуры чтобы не выходить за границы поля
  if (!rotate_check_field(matrix, brick)) { // если после поворота есть пересечение с другими блоками поля
    brick_copy(brick, temp_brick); // откатываем изменения — восстанавливаем исходные координаты из temp_brick
  } // конец проверки соприкосновения с полем
  free(temp_brick); // освобождаем временный буфер координат
  free_memory_matrix(temp, size); // освобождаем временную матрицу temp
  free_memory_matrix(rotate, size); // освобождаем матрицу rotate
} // конец метода rotate

/**
 * @brief Проверяет столкновение фигуры с нижней границей поля.
 *
 * @return 1 если нет столкновения, иначе 0
 */
int Tetris::rotate_check_down_wall(int* brick) { // начало метода проверки выхода за нижнюю границу
  int res = 1; // по умолчанию считаем что выхода нет
  for (int i = 0; i < BRICK_SIZE; i += 2) { // проходим по индексам Y в массиве координат
    if (brick[i] >= WINDOW_HEIGHT) res = 0; // если хотя бы одна Y координата выходит за границу — помечаем как столкновение
  } // конец цикла проверки Y координат
  return res; // возвращаем результат проверки
} // конец метода rotate_check_down_wall

/**
 * @brief Проверяет столкновение фигуры с левой границей поля.
 *
 * @return 1 если нет столкновения, иначе 0
 */
int Tetris::rotate_check_left_wall(int* brick) { // начало метода проверки выхода за левую границу
  int res = 1; // по умолчанию считаем что выхода нет
  for (int i = 1; i < BRICK_SIZE; i += 2) { // проходим по индексам X в массиве координат
    if ((brick[i] < 0)) { // если хотя бы одна X координата меньше 0 (вышла за левую границу)
      res = 0; // помечаем как столкновение
    } // конец условия проверки для текущего блока
  } // конец цикла проверки X координат
  return res; // возвращаем результат проверки
} // конец метода rotate_check_left_wall

/**
 * @brief Проверяет столкновение фигуры с правой границей поля.
 *
 * @return 1 если нет столкновения, иначе 0
 */
int Tetris::rotate_check_right_wall(int* brick) { // начало метода проверки выхода за правую границу
  int res = 1; // предполагаем, что выхода не происходит
  for (int i = 1; i < BRICK_SIZE; i += 2) { // проходим по индексам X в массиве координат
    if ((brick[i] >= WINDOW_WIDTH)) { // если хотя бы одна X координата больше или равна ширине поля
      res = 0; // помечаем как столкновение с правой стенкой
    } // конец условия проверки для текущего блока
  } // конец цикла проверки правой границы
  return res; // возвращаем результат проверки
} // конец метода rotate_check_right_wall

/**
 * @brief Проверяет столкновение фигуры с верхней границей поля.
 *
 * @return 1 если нет столкновения, иначе 0
 */
int Tetris::rotate_check_up_wall(int* brick) { // начало метода проверки выхода за верхнюю границу
  int res = 1; // предполагаем отсутствие выхода за границы
  for (int i = 0; i < BRICK_SIZE; i += 2) { // проходим по индексам Y в массиве координат
    if (brick[i] < 0) res = 0; // если хотя бы одна Y координата меньше 0 — отмечаем столкновение с верхней границей
  } // конец цикла проверки верхней границы
  return res; // возвращаем результат проверки
} // конец метода rotate_check_up_wall


/**
 * @brief Обрабатывает движение фигуры по игровому полю.
 *
 * Проверяет возможность смещения фигуры влево, вправо
 * или поворота, учитывая тип фигуры.
 */
void Tetris::brick_move(int* brick, UserAction_t state, int** matrix) { // начало метода обработки пользовательского перемещения фигуры
  if (state == Left && check_left(matrix, brick, 1)) { // если действие — влево и проверка позволяет сдвинуть
    coord_shift(brick, X_CORDS, LEFT); // сдвигаем фигуру влево по X
  } else if (state == Right && check_right(matrix, brick, 1)) { // если действие — вправо и проверка разрешает сдвиг
    coord_shift(brick, X_CORDS, RIGHT); // сдвигаем фигуру вправо по X
  } else if (state == Action && !is_Smashboy(brick)) { // если действие — поворот и фигура не квадрат (Smashboy не поворачивается)
    if (is_Hero(brick)) { // если фигура — Hero (линейная)
      rotate(matrix, brick, 5); // поворачиваем с использованием центра в матрице размера 5
    } else {
      rotate(matrix, brick, 3); // поворачиваем с использованием центра в матрице размера 3
    } // конец выбора размера поворота по типу фигуры
  } // конец условий обработки перемещения/поворота
} // конец метода brick_move

/**
 * @brief Проверяет, есть ли столкновение фигуры с другими блоками на поле.
 *
 * @return 1 если свободно, иначе 0
 */
int Tetris::rotate_check_field(int** matrix, int* brick) { // начало метода проверки пересечений фигуры с уже занятыми ячейками поля
  int res = 1; // по умолчанию считаем, что пересечений нет
  for (int i = 0; i < BRICK_SIZE; i += 2) { // проходим по всем блокам фигуры (Y,X пары)
    if (matrix[brick[i]][brick[i + 1]]) { // если соответствующая ячейка поля ненулевая (занята)
      res = 0; // помечаем наличие пересечения
    } // конец условия проверки конкретной ячейки
  } // конец цикла проверки всех блоков фигуры
  return res; // возвращаем результат проверки поля
} // конец метода rotate_check_field

/**
 * @brief Корректирует координаты фигуры, чтобы она не выходила за границы поля.
 */
void Tetris::fix_brick_coord(int* brick) { // начало метода корректировки координат фигуры по всем границам поля
  while (!rotate_check_right_wall(brick)) { // пока есть выход за правую границу
    coord_shift(brick, X_CORDS, LEFT); // сдвигаем фигуру влево до вхождения в поле
  } // конец цикла корректировки по правой границе
  while (!rotate_check_left_wall(brick)) { // пока есть выход за левую границу
    coord_shift(brick, X_CORDS, RIGHT); // сдвигаем фигуру вправо до вхождения в поле
  } // конец цикла корректировки по левой границе
  while (!rotate_check_down_wall(brick)) { // пока есть выход за нижнюю границу
    coord_shift(brick, Y_CORDS, UP); // сдвигаем фигуру вверх до вхождения в поле
  } // конец цикла корректировки по нижней границе
  while (!rotate_check_up_wall(brick)) { // пока есть выход за верхнюю границу
    coord_shift(brick, Y_CORDS, DOWN); // сдвигаем фигуру вниз до вхождения в поле
  } // конец цикла корректировки по верхней границе
} // конец метода fix_brick_coord

/**
 * @brief Проверяет уровень игрока и увеличивает скорость игры при необходимости.
 */
void Tetris::check_level(Tetris* tetris) { // начало метода проверки и обновления уровня/скорости
  if (tetris->gameinfo.level < 10 && // если текущий уровень меньше 10
      (tetris->gameinfo.score - (tetris->gameinfo.level * 600) >= 0)) { // и набрано достаточно очков для перехода на следующий уровень
    tetris->gameinfo.level++; // увеличиваем уровень на 1
    tetris->gameinfo.speed++; // увеличиваем скорость игры на 1
  } // конец условия проверки уровня
} // конец метода check_level
/**
 * @brief Копирует координаты фигуры из одного массива в другой.
 */
void Tetris::brick_copy(int* src, int* other) { // начало метода копирования массива координат фигуры
  for (int i = 0; i < BRICK_SIZE; i++) { // цикл по всем элементам массива размером BRICK_SIZE
    src[i] = other[i]; // копируем значение из массива other в src
  } // конец цикла копирования
} // конец метода brick_copy

/**
 * @brief Проверяет условия окончания игры.
 *
 * @return 1 если фигура достигла верхнего ряда, иначе 0
 */
int Tetris::check_gameover(int* brick) { // начало метода проверки условия Game Over (достижение верха)
  int res = 0; // по умолчанию игра не окончена
  for (int i = 0; i < BRICK_SIZE; i += 2) { // проходим по всем Y координатам блоков фигуры
    if (brick[i] == 0) { // если любой блок находится в верхней строке (Y == 0)
      res = 1; // помечаем условие конца игры
    } // конец проверки конкретного блока
  } // конец цикла проверки всех блоков
  return res; // возвращаем результат проверки
} // конец метода check_gameover

/**
 * @brief Увеличивает счёт игрока и обновляет рекорд.
 *
 * @param full_rows_counter количество удалённых строк
 */
void Tetris::score_write(Tetris* tetris, int full_rows_counter) { // начало метода обновления счёта и записи рекорда
  if (full_rows_counter == 1) { // один удалённый ряд
    tetris->gameinfo.score += 100; // начисляем 100 очков
  } else if (full_rows_counter == 2) { // два удалённых ряда
    tetris->gameinfo.score += 300; // начисляем 300 очков
  } else if (full_rows_counter == 3) { // три удалённых ряда
    tetris->gameinfo.score += 700; // начисляем 700 очков
  } else if (full_rows_counter == 4) { // четыре удалённых ряда (тетриш)
    tetris->gameinfo.score += 1500; // начисляем 1500 очков
  } // конец расчёта очков за удалённые строки
  if (tetris->gameinfo.score > tetris->gameinfo.high_score) { // если текущий счёт превысил рекорд
    tetris->gameinfo.high_score = tetris->gameinfo.score; // обновляем рекорд в структуре
    FILE* file; // указатель на файл для записи рекорда
    const char* filename = DATA_FILE_NAME; // имя файла с рекордом
    int record = tetris->gameinfo.high_score; // локальная копия значения рекорда для записи
    file = fopen(filename, "wb"); // открываем файл для записи в бинарном режиме (перезаписываем)
    if (file != NULL) { // если файл открылся успешно
      fwrite(&record, sizeof(int), 1, file); // записываем значение рекорда в файл
      fclose(file); // закрываем файл после записи
    } // конец проверки успешного открытия файла для записи
  } // конец условия обновления рекорда
} // конец метода score_write


}  // namespace s21 // конец пространства имён s21

