#ifndef SNAKE_H // защита от повторного включения заголовка: если SNAKE_H не определён
#define SNAKE_H // определяет макрос SNAKE_H чтобы избежать повторного включения

#include <chrono> // подключает заголовок для работы со временем и таймерами
#include <fstream> // подключает заголовок для файлового ввода/вывода
#include <memory> // подключает заголовок для умных указателей и управления памятью
#include <random> // подключает заголовок для генерации случайных чисел
#include <vector> // подключает заголовок для использования std::vector

#include "../brick_game_single.h" // подключает общий заголовок с базовыми типами и абстрактным классом Game

namespace s21 { // начало пространства имён s21

/**
 * @brief Класс змейки.
 *
 * Наследуется от абстрактного класса Game.
 * Интерфейс представлен функцией get_instance(), которая дает доступ к единственному экземпляру класса.
 */
class Snake : public Game { // объявление класса Snake, наследника Game
 private: // начало секции приватных членов класса
  Snake(); // приватный конструктор по умолчанию (скрывает создание извне)
  Snake(const Snake&) = delete; // удалённый копирующий конструктор, запрещает копирование
  Snake& operator=(const Snake&) = delete; // удалённый оператор присваивания, запрещает присваивание
  ~Snake(); // приватный деструктор

  void starting_game() override; // метод инициализации состояния Start переопределённый от Game
  void spawn() override; // метод появления начального состояния/объектов переопределённый
  void moving() override; // метод обработки движения змейки переопределённый
  void shifting() override; // метод сдвига состояния переопределённый
  void attaching() override; // метод прикрепления/обработки столкновения переопределённый
  void game_over() override; // метод обработки конца игры переопределённый

 public: // публичная секция класса
  static Snake* get_instance() { // статический метод доступа к единственному экземпляру (синглтон)
    static Snake instance; // локальный статический экземпляр, обеспечивающий единственность
    return &instance; // возвращает указатель на единственный экземпляр
  } // конец метода get_instance

 private: // приватная секция для внутренних типов и полей
  enum class Direction { Dir_Left = 0, Dir_Right, Dir_Up, Dir_Down }; // перечисление направлений движения змейки

  std::pair<int, int>* snake_coords; // указатель на динамический массив координат сегментов змейки (Y,X пары)
  std::pair<int, int> apple_coords; // координаты текущего яблока (Y,X)
  Direction curr_direction; // текущее направление движения змейки
  Timer timer; // объект таймера для управления скоростью/периодом шагов
  int snake_size; // текущий размер змейки (количество сегментов)

 private: // приватная секция методов вспомогательной логики
  void init_statistic(); // инициализация начальной статистики и стартовых параметров игры
  void init_record(); // инициализация механизма работы с рекордом (файл/поле)
  bool read_record_file(); // чтение рекорда из файла, возвращает true при успехе
  void write_record_file(const int number); // запись переданного рекордного числа в файл
  void spawn_apple(); // генерация и размещение яблока на свободной клетке поля
  void snake_position_update(const int value); // обновление отображения змейки на поле (SPAWN/DESPAWN)
  void rotate_head(); // смещение координат головы в соответствии с направлением
  bool check_collide_apple_of_snake() const; // проверка столкновения головы с яблоком
  bool check_collide_body_head() const; // проверка столкновения головы с собственным телом
  bool coord_valid_check(const std::pair<int, int> coords) const; // проверка валидности переданных координат
  bool check_rotate_head() const; // проверка допустимости поворота головы по текущему направлению и действию
  void set_direction(); // установка нового направления движения на основе действия игрока
  void pause_game(); // переключение состояния паузы игры
  void shift_to_head(); // сдвиг массивa координат змейки от хвоста к голове
  void get_free_cells(std::vector<std::pair<int, int>>& free_cells) const; // сбор всех свободных клеток поля в вектор
  int get_random_index(const size_t free_cells_size) const; // получение случайного индекса в диапазоне размера вектора свободных клеток
  void update_score_game(); // увеличение счёта и обновление рекорда при необходимости
  void update_level_speed(); // обновление уровня и скорости в зависимости от набранных очков
}; // конец объявления класса Snake

}  // namespace s21 // конец пространства имён s21

#endif  // SNAKE_H // конец защиты от повторного включения заголовка